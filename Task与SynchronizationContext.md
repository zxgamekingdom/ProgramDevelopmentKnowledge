# 问题原因：

Windows Form、WPF、UWP等等UI库中都有的同步上下文`SynchronizationContext`。

Task在带有同步上下文的环境中运行时，如果Task完成时,是会自动去捕获同步上下文的，并将Task之后的同步逻辑提交给同步上下文中去执行。

但是同步上下文的UI线程已经阻塞等待Task完成，而Task在完成时无法提交同步逻辑给同步上下文导致死锁。
# 解决办法：

如果要在只能是同步环境中等待复杂的Task逻辑，使用信号量；

如果在可以是非同步环境中等待复杂的Task逻辑，使用await；
